with Ada.Characters.Conversions;
with Ada.Command_Line;
with Ada.Containers.Indefinite_Hashed_Maps;
with Ada.Containers.Indefinite_Hashed_Sets;
with Ada.Containers.Indefinite_Vectors;
with Ada.Direct_IO;
with Ada.Directories;
with Ada.Strings.Fixed;
with Ada.Strings.Hash;
with Ada.Strings.Maps;
with Ada.Text_IO;

procedure Init_Generator is
   -- This program is used for generating the body of GL.Init. It uses a
   -- horrible lexer to read GL.API and a horrible parser to extract variables
   -- that need initialization.

   -- I could have used an existing, proper Ada lexer / parser instead but
   -- because the features needed here are manageable, I opted to dirty-code it
   -- on my own to avoid dependencies.

   -- For each variable in GL.API, a loading statement is generated. The OpenGL
   -- name of the function that should be loaded to that variable shall be given
   -- as comment directly behind the variable declaration.

   use Ada.Directories;

   type Symbol_Id is new Positive;

   package String_Indexer is new Ada.Containers.Indefinite_Hashed_Maps
     (String, Symbol_Id, Ada.Strings.Hash, Standard."=");

   GL_API_File_Path : constant String := "src/gl/implementation/gl-api.ads";
   Generated_Directory_Path : constant String := "src/generated";
   Generated_File_Path : constant String :=
     Generated_Directory_Path & "/gl-init.adb";

   function Load_File (Path : String) return String is
      File_Size : Natural := Natural (Ada.Directories.Size (Path));
      subtype File_String    is String (1 .. File_Size);
      package File_String_IO is new Ada.Direct_IO (File_String);
      File : File_String_IO.File_Type;
   begin
      Ada.Text_IO.Put_Line ("Loading " & Path & "...");
      File_String_IO.Open (File, File_String_IO.In_File, Path);
      return Contents : File_String do
         File_String_IO.Read (File, Contents);
         File_String_IO.Close (File);
         Ada.Text_IO.Put_Line ("... loaded successfully!");
      end return;
   end Load_File;

   Output_File : Ada.Text_IO.File_Type;

   procedure Write_File_Header is
      use Ada.Text_IO;
   begin
      Put_Line (Output_File, "-- Autogenerated by Init_Generator, do not edit");
      Put_Line (Output_File, "with GL.API;");
      Put_Line (Output_File, "with System;");
      Put_Line (Output_File, "with Ada.Unchecked_Conversion;");
      Put_Line (Output_File, "private generic");
      Put_Line (Output_File, "   with function Raw_Subprogram_Reference (Name : String) return System.Address;");
      Put_Line (Output_File, "procedure GL.Load_Function_Pointers is");
      Put_Line (Output_File, "   use GL.API;");
      Put_Line (Output_File, "   generic");
      Put_Line (Output_File, "      type Function_Reference is private;");
      Put_Line (Output_File, "   function Load (Function_Name : String) return Function_Reference;");
      Put_Line (Output_File, "   pragma Inline (Load);");
      Put_Line (Output_File, "   function Load (Function_Name : String) return Function_Reference is");
      Put_Line (Output_File, "      function As_Function_Reference is new Ada.Unchecked_Conversion (");
      Put_Line (Output_File, "        Source => System.Address, Target => Function_Reference);");
      Put_Line (Output_File, "      Raw : System.Address := Raw_Subprogram_Reference (Function_Name);");
      Put_Line (Output_File, "   begin");
      Put_Line (Output_File, "      if Raw = System.Null_Address then");
      Put_Line (Output_File, "         Raw := Raw_Subprogram_Reference (Function_Name & ""ARB"");");
      Put_Line (Output_File, "         if Raw = System.Null_Address then");
      Put_Line (Output_File, "            Raw := Raw_Subprogram_Reference (Function_Name & ""EXT"");");
      Put_Line (Output_File, "         end if;");
      Put_Line (Output_File, "      end if;");
      Put_Line (Output_File, "   end Load;");
   end Write_File_Header;

   package Tokenizer is
      Paren_Depth : Natural := 0;

      type Token_Kind is (Identifier, Numeric_Literal, String_Literal,
        Delimiter, Comment);

      type Token (Length : Natural) is limited record
         Kind : Token_Kind;
         Content : String (1 .. Length);
      end record;

      function Next return Token;
   private
      Input : String := Load_File (GL_API_File_Path);
      Pos : Positive := Input'First;
   end Tokenizer;

   package body Tokenizer is
      use Ada.Strings.Maps;

      Inline_Separators : constant Character_Set :=
        To_Set (Character'Val (9)) or To_Set (' ');

      Newlines : constant Character_Set :=
        To_Set (Character'Val (10)) or To_Set (Character'Val (13));

      Separators : constant Character_Set :=
         Inline_Separators or Newlines;

      Single_Delimiters : constant Character_Set :=
         To_Set ("&'()*+,-./:;<=>|");

      Compound_Delimiters : constant array(1 .. 10) of String (1 .. 2) :=
         ("=>", "..", "**", ":=", "/=", ">=", "<=", "<<", ">>", "<>");

      function Next return Token is
         I : Positive := Pos;
         Cur : Character;

         procedure Skip (Set : Character_Set) is
         begin
            while I <= Input'Length loop
               Cur := Input (I);
               exit when not Is_In (Cur, Set);
               I := I + 1;
            end loop;
         end Skip;
      begin
         Skip (Separators);
         Pos := I;

         if I > Input'Length then
            raise Program_Error with "Unexpected file end";
         end if;

         if Is_In (Cur, Single_Delimiters) then
            I := I + 1;
            if I <= Input'Length then
               declare
                  Next : constant Character := Input (I);
               begin
                  if Cur = '-' and Next = '-' then
                     I := I + 1;
                     Skip (Inline_Separators);
                     Pos := I;
                     Skip (not Newlines);

                     return Ret : Token :=
                       Token'(Kind => Comment, Length => I - Pos,
                              Content => Input (Pos .. I - 1)) do
                        Pos := I;
                     end return;
                  else
                     declare
                        Possible_Compound : String := Cur & Next;
                     begin
                        for J in 1 .. 10 loop
                           if Compound_Delimiters (J) = Possible_Compound then
                              Pos := I + 1;
                              return Token'(Kind => Delimiter, Length => 2,
                                            Content => Possible_Compound);
                           end if;
                        end loop;
                        Pos := I;
                        if Cur = '(' then
                           Paren_Depth := Paren_Depth + 1;
                        elsif Cur = ')' then
                           Paren_Depth := Paren_Depth - 1;
                        end if;
                        return Token'(Kind => Delimiter, Length => 1,
                                      Content => (1 => Cur));
                     end;
                  end if;
               end;
            else
               Pos := I;
               return Token'(Kind => Delimiter, Length => 1, Content => (1 => Cur));
            end if;
         elsif Cur = '"' then
            I := I + 1;
            Pos := I;
            while I <= Input'Length loop
               <<continue>>
               Cur := Input (I);
               if Cur = '"' then
                  if I < Input'Length then
                     if Input (I + 1) = '"' then
                        I := I + 2;
                        goto continue;
                     end if;
                  end if;
                  return Ret : Token := Token'(Kind => String_Literal,
                    Length => I - Pos, Content => Input (Pos .. I - 1)) do
                     Pos := I + 1;
                  end return;
               end if;
               I := I + 1;
            end loop;
            raise Program_Error with "Unclosed string literal";
         else
            Skip (not (Separators or Single_Delimiters));
            return Ret : Token := Token'(Kind => Identifier, Length => I - Pos,
              Content => Input (Pos .. I - 1)) do
               Pos := I;
            end return;
         end if;
      end Next;
   end Tokenizer;

   use type Tokenizer.Token_Kind;

   package Type_Collection is new Ada.Containers.Indefinite_Hashed_Sets
     (String, Ada.Strings.Hash, Standard."=");

   At_Declaration : Boolean := False;


   procedure Skip_To_Semicolon is
   begin
      loop
         declare
            Cur : constant Tokenizer.Token := Tokenizer.Next;
         begin
            exit when Tokenizer.Paren_Depth = 0 and
              Cur.Kind = Tokenizer.Delimiter and Cur.Content = ";";
         end;
      end loop;
      At_Declaration := True;
   end Skip_To_Semicolon;

   package String_Lists is new Ada.Containers.Indefinite_Vectors
     (Positive, String);

   Var_Setters : String_Lists.Vector;
   Symbol_Table   : String_Indexer.Map;
   Function_Types : Type_Collection.Set;

   procedure Process_Variable (Name : String) is
      Next : constant Tokenizer.Token := Tokenizer.Next;
   begin
      if Next.Kind = Tokenizer.Delimiter and Next.Content = ":" then
         Ada.Text_IO.Put_Line ("Found variable: " & Name);
         declare
            Type_Name : constant Tokenizer.Token := Tokenizer.Next;
         begin
            if Type_Name.Kind = Tokenizer.Identifier and then
              Function_Types.Contains (Type_Name.Content) then
               Ada.Text_IO.Put_Line ("Known function type!");
               Skip_To_Semicolon;
               declare
                  Succ_Comment : constant Tokenizer.Token := Tokenizer.Next;
               begin
                  if Succ_Comment.Kind /= Tokenizer.Comment then
                     raise Program_Error with
                       "Missing OpenGL function name comment for variable " &
                       Name;
                  end if;
                  Var_Setters.Append (Name & " := Load_" &
                    Type_Name.Content & " (""" & Ada.Strings.Fixed.Trim
                      (Succ_Comment.Content, Ada.Strings.Both) & """);");
               end;
            else
               Ada.Text_IO.Put_Line ("Unknown function type: " & Type_Name.Content);
               Skip_To_Semicolon;
            end if;
         end;
      else
         raise Program_Error with "Unexpected token: " & Name;
      end if;
   end Process_Variable;

   function Id (Symbol : String) return Symbol_Id is
      use String_Indexer;
      use type Ada.Containers.Count_Type;
      Position: Cursor;
      Inserted: Boolean;
   begin
      Symbol_Table.Insert
        (Symbol, Symbol_Id (Symbol_Table.Length + 1), Position, Inserted);
      return Element (Position);
   end Id;

   Keyword_Access    : constant Symbol_Id := Id ("access");
   Keyword_Function  : constant Symbol_Id := Id ("function");
   Keyword_Is        : constant Symbol_Id := Id ("is");
   Keyword_Package   : constant Symbol_Id := Id ("package");
   Keyword_Pragma    : constant Symbol_Id := Id ("pragma");
   Keyword_Procedure : constant Symbol_Id := Id ("procedure");
   Keyword_Subtype   : constant Symbol_Id := Id ("subtype");
   Keyword_Type      : constant Symbol_Id := Id ("type");
   Keyword_Use       : constant Symbol_Id := Id ("use");

   procedure Process_Type is
      Name : constant Tokenizer.Token := Tokenizer.Next;
   begin
      if Name.Kind /= Tokenizer.Identifier then
         raise Program_Error with "Unexpected token: " & Name.Content;
      end if;
      declare
         Is_Token : constant Tokenizer.Token := Tokenizer.Next;
      begin
         if Is_Token.Kind /= Tokenizer.Identifier or else
           Id (Is_Token.Content) /= Keyword_Is then
            raise Program_Error with "Unexpected token: " & Is_Token.Content;
         end if;
      end;
      declare
         Type_Start : constant Tokenizer.Token := Tokenizer.Next;
      begin
         if Type_Start.Kind /= Tokenizer.Identifier or else
           Id (Type_Start.Content) /= Keyword_Access then
            Skip_To_Semicolon;
         else
            declare
               Access_Kind : constant Tokenizer.Token := Tokenizer.Next;
            begin
               if Access_Kind.Kind /= Tokenizer.Identifier or else
                 not (Id (Access_Kind.Content) in Keyword_Procedure | Keyword_Function)
                 then
                  Skip_To_Semicolon;
               else
                  Ada.Text_IO.Put_Line ("Adding type: " & Name.Content);
                  Function_Types.Insert (Name.Content);
                  Ada.Text_IO.Put_Line (Output_File,
                    "   function Load_" & Name.Content &
                    " is new Load (" & Name.Content & ");");
               end if;
            end;
         end if;
      end;
   end Process_Type;

   Saw_Is : Boolean := False;
   Depth : Natural := 0;
begin
   Ada.Directories.Create_Path (Generated_Directory_Path);
   Ada.Text_IO.Create (Output_File, Ada.Text_IO.Out_File, Generated_File_Path);
   Write_File_Header;

   loop
      <<continue>>
      declare
         Cur : constant Tokenizer.Token := Tokenizer.Next;
      begin
         if Cur.Kind = Tokenizer.Identifier then
            if Cur.Content = "is" then
               Saw_Is := True;
               Depth := Depth + 1;
               At_Declaration := True;
               goto continue;
            elsif Cur.Content = "then" or
              Cur.Content = "loop" then
               Depth := Depth + 1;
               At_Declaration := True;
               goto continue;
            elsif Cur.Content = "end" or Cur.Content = "until" then
               Depth := Depth - 1;
               exit when Depth = 0;
               Skip_To_Semicolon;
               goto continue;
            elsif Cur.Content = "new" and Saw_Is then
               Depth := Depth - 1;
               Skip_To_Semicolon;
               goto continue;
            end if;
         end if;
         Saw_Is := False;
         if Depth /= 1 then
            goto continue;
         end if;
         if At_Declaration then
            if Cur.Kind = Tokenizer.Identifier then
               declare
                  Symbol : constant Symbol_Id := Id (Cur.Content);
               begin
                  if Symbol in Keyword_Procedure | Keyword_Pragma |
                    Keyword_Function | Keyword_Use | Keyword_Package then
                     At_Declaration := False;
                  elsif Symbol in Keyword_Type | Keyword_Subtype then
                     Process_Type;
                  else
                     Process_Variable (Cur.Content);
                  end if;
               end;
            elsif Cur.Kind /= Tokenizer.Comment then
               Skip_To_Semicolon;
            end if;
         elsif Cur.Kind = Tokenizer.Delimiter and then
           (Cur.Content = ";" and then Tokenizer.Paren_Depth = 0) then
            At_Declaration := True;
         end if;
      end;
   end loop;

   Ada.Text_IO.Put_Line (Output_File, "begin");
   for Line of Var_Setters loop
      Ada.Text_IO.Put_Line (Output_File, "   " & Line);
   end loop;
   Ada.Text_IO.Put_Line (Output_File, "end GL.Init;");

   Ada.Text_IO.Close (Output_File);
end Init_Generator;